# 函数 #
## 函数定义 ##

![](http://introcs.cs.princeton.edu/python/21function/images/AnatomyMethod.png "Defining Functions")

- 第一行为**函数签名(signature)**，用于指定函数名称(function name)和每个形式参数变量名称。函数签名包括**关键字`def`**、**函数名**、**一个或多个形式参数变量名**、**英文冒号**。
- 紧跟函数签名后的缩进代码定义**函数体(function body)**。
- 函数体中**还可以**包含一条**`return`语句**。
- 函数体还可以定义**局部变量(local variable)**

## 控制流程 ##

![](http://introcs.cs.princeton.edu/python/21function/images/FlowEZ.png)

1. 首先，处理`import`语句。
2. 然后，Python处理函数定义，但不会执行函数，仅当调用函数时Python才会执行函数。
3. 执行全局代码。

> **注意：**函数定义的位置必须位于调用该函数的全局代码之前。

## 变量的作用范围 ##

- 函数的**局部变量**和**形参变量**的作用范围仅限于函数本身。
- 全局代码中定义的变量(全局变量)的作用范围局限于包含该变量的整个`.py`文件。
- 全局代码不能引用一个函数的局部变量或形参变量。
- 一个函数也不能引用在另一个函数中定义的局部变量或形参变量。
- 如果在一个函数中定义的局部变量（或形参变量）与全局变量重名，则局部变量优先。

> 软件设计的指导原则是：定义变量的作用范围越小越好。所以，强烈建议不要在函数中引用全局变量：应该使用函数形参变量实现与其函数的通信，而函数则应该使用`return`语句实现与其调用者的所有通信。

## 默认参数 ##

- 有些API函数如`math.log(x)`和`math.log(x, b)`，如果只传入一个函数，则`b`默认为自然对数`e`。
- 在自定义函数中，通过在函数签名的参数变量后使用等号和默认值，指定该形式参数变量为带默认值的可选参数。

```
def harmonic(n, r=1)
```

## 类型检查 ##

**Python语言中，不用指定形式参数变量的类型，也不用指定返回值的类型**。

只要Python能够完成函数中的所有运算操作，Python就会执行完函数并返回结果。

如果由于给定对象的类型不匹配，Python无法完成一个运算操作，Python将抛出一个运行错误并指出错误类型。

>这称为多态性(polymorphism)

## 传递参数和返回值 ##
### 通过对象引用实现调用 ###
Python使用调用传递对应的实际参数来初始化形式参数变量。我们称之为“**通过对象引用实现调用(call by object reference)**”。(更常见的说话是值调用)

### 不可变性和别名 ###
一个数据类型是不可变的(immutable)，是指该数据类型对象的值是不可变的。

数据类型(int/float/str/bool)都是不可变的。对于不可变的数据类型，有些操作看上去修改了对象的值，但实际上创建了一个新的对象。

例如：

	i = 99
	j =i
	j += 1

>首先，语句`i = 99`创建了一个整数对象`99`，并把指向该对象的引用赋值给了变量`i`。然后执行语句`j = i`，把`i`(赋值引用)赋值给`j`，所以变量`i`和`j`都引用同一个对象。如果两个变量指向同一个对象，则互称别名。最后，执行`j += 1`，其结果是`j`引用一个值为`100`的对象，但语句并没有将已存在的值为`99`的整型对象的值改变为`100`。实际上，因为`int`对象为不可变对象，所以没有语句可以改变一个既存整型对象的值。事实上，该语句创建了一个新的整型对象`1`,加上整数`99`并创建另一个新的整型对象`100`，并把指向该整数的对象引用赋值给变量`j`。但是，`i`依旧指向原来的`99`。

**所以传递实际参数给一个函数，实参和形参是互为别名。**

举例：

	def inc(j)
		j += 1
	i = 99
	inc(i)
>此时，`i`和`j`互为别名。函数`inc()`的语句`j += 1`不会改变整数99，而是创建一个新的整数100，并把其对象引用赋值给变量`j`。但是，当函数`inc()`调用结束返回到调用者后，其形式参数变量`j`超出了作用范围，而变量`i`依旧指向整数99。

### 数组作为参数 ###
**数组是可变(mutable)的数据类型**，我们可以改变数组元素的值。

**所以，当传递一个数组作为函数的实际参数时，可以直接操作该数组(而不是该数组的副本)**

举例

	def exchange(a, i, j)
		temp = a[i]
		a[i] = a[j]
		a[j] = temp
	x = [.30, .60, .10]
	exchange(x, 0, 2)
>运算过后，`x = [0.10, 0.60, 0.30]`