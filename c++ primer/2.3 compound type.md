# 复合类型 #
复合类型是指基于其他类型定义的类型

- **引用**
- **指针**

-----
# 引用 #
**引用**(reference)为对象起另外一个名字。
	
	int ival = 1024;
	int &refVal = ival; //refVal是ival的另一个名字

> 定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。 一旦初始化完成，引用将和它的初始化值永远绑定在一起。**无法令引用重新绑定到另外一个对象，因此引用必须初始化。**

### 引用即别名 ###

- 定义了一个引用之后，**对其进行的所有操作都是在与之绑定的对象上进行的**
- 引用本身不是一个对象，所以**不能定义引用的引用**
- 除了两种特例外，其他所有引用的类型都要和与之绑定的对象严格匹配。
> 第一种例外情况是：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

	int &refVal = 10; //error:引用类型的初始值必须是一个对象
	int &refVal2;	  //error: 引用必须被初始化
	double dval = 3.14;
	int &refVal3 = dval; //error:此处引用的初始值必须是double对象

---

# 指针 #

> 指针与引用相比有很大不同

- 指针本身是一个对象，允许对指针赋值和拷贝，在指针的生命周期内可以先后指向不同的对象
- 指针**无须**在定义时附初值。 

### 获取对象的地址 ###
使用**取地址符(`&`)**。

	int ival = 42;
	int *p = &ival;

`int *p = &ival`等价于`int *p; p = &ival;`

> 因为引用不是对象，**没有实际地址**，所以不能定义指向引用的指针。

除两种例外情况外，其他所有的指针的类型都要和它所指向的对象严格匹配。

### 指针值 ###
指针的值(即地址)应该是下面4钟状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象。
4. 无效指针，上述情况之外的指针。

### 指向一个对象的指针 ###
使用**解引用符(`*`)**来访问该对象。

	int ival = 42;
	int *p = &ival;
	*p = 0;
	cout << *p;

> `&`符号和`*`符号的区分

	int i = 42;
	int &r = i; // &紧随类型名出现，因此是声明的一部分，r是一个引用
	int *p; // *紧随类型名出现，因此是声明的一部分，p是一个指针
	p = &i; // &出现在表达式中，是一个取地址符
	*p = i; // *出现在表达式中，是一个解引用符
	int &r2 = *p; // &是声明的一部分，*是一个解引用符

### 空指针 ###
空指针的生成方法：

	int *p1 = nullptr;
	int *p2 = 0;
	int *p3 = NULL; //需要#include cstdlib

> 获得空指针最直接的方法就是使用**字面值`nullptr`**来初始化指针，这也是c++ 11引入的一种方法。新标准下，最好使用`nullptr`，尽量避免使用`NULL`;

**将int变量直接赋给指针是错误的操作**，即使int变量的值恰好等于0也不行。

	int zero = 0;
	pi = zero; //error:不能把int变量直接赋给指针

### 赋值和指针 ###
赋值**永远是改变等号左侧的对象**

`pi = &ival;` //指针的值被改变

`*po = 0;` //指针所指的对象发生改变

### 指针相等 ###
指针相等也就是**两个指针存放的地址值相同**，有三种情况：

- 它们都为空
- 都指向同一个对象
- 都指向同一个对象的下一个地址

### void* 指针 ###
`void*`是一种特殊的指针类型，可用于存放任意对象的地址。
不能直接操作`void*`指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

----------

# 复合类型的声明 #
变量的定义 = **基本数据类型** + **一组声明符**。

声明符 = **类型修饰符(\*或&)** + **变量名** （类型修饰符可以没有）。

	int* p; //合法但容易产生误导，着重强调定义了一种复合类型
> 上述基本的数据类型是`int`而非`int*`，`*`仅仅是修饰了`p`而已，对该声明语句中的其他变量，并不产生作用。

	int *p1, *p2; //这种更值得推荐，强调变量具有的复合类型。

### 指向指针的引用 ###
指针是对象，所以存在对指针的引用。

	int i = 42;
	int *p;
	int *&r = p;

> 要理解`r`到底是什么，最简单的方法**是从右向左**阅读`r`的定义。

**离变量名最近的符号**(变量名是`r`，最近的符号是`&`)，因此`r`是一个引用。**声明符的其余部分**用以确定`r`引用的类型是什么(符号`*`说明`r`引用的是一个指针)。最后，**声明的基本类型部分**指出`r`引用的是一个`int`指针。

12/14/2016 4:17:14 PM 